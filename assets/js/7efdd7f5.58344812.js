"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[146],{5431:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return l},contentTitle:function(){return o},metadata:function(){return p},toc:function(){return c},default:function(){return h}});var i=a(7462),n=a(3366),r=(a(7294),a(3905)),s=["components"],l={id:"ctypes",title:"CTypes"},o=void 0,p={unversionedId:"sdk/core-feature/ctypes",id:"sdk/core-feature/ctypes",isDocsHomePage:!1,title:"CTypes",description:"CTypes are standardised structures for credentials; the JSON scheme which describes the fields in a claim type. These fields are filled out by the claimer, indicating the information that needs to be attested. A CType (and subsequently when attested, the credential) may contain several \u201cattributes\u201d, for example, full name, date of birth, access level and id number.",source:"@site/docs/sdk/0-core-feature/1_ctypes.md",sourceDirName:"sdk/0-core-feature",slug:"/sdk/core-feature/ctypes",permalink:"/docs/sdk/core-feature/ctypes",editUrl:"https://github.com/KILTprotocol/docs/edit/master/docs/sdk/0-core-feature/1_ctypes.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"ctypes",title:"CTypes"},sidebar:"sdk",previous:{title:"Kilt DIDs",permalink:"/docs/sdk/core-feature/did"},next:{title:"Claiming",permalink:"/docs/sdk/core-feature/claiming"}},c=[{value:"Json-Schema",id:"json-schema",children:[{value:"Properties",id:"properties",children:[],level:3},{value:"Referencing",id:"referencing",children:[],level:3}],level:2},{value:"CType Metadata",id:"ctype-metadata",children:[],level:2},{value:"Hashing",id:"hashing",children:[{value:"Constructing the <code>hash</code> for the <code>$id</code>",id:"constructing-the-hash-for-the-id",children:[],level:3}],level:2},{value:"Storing CTypes",id:"storing-ctypes",children:[],level:2},{value:"Exchange of CTypes with different actors",id:"exchange-of-ctypes-with-different-actors",children:[],level:2}],d={toc:c};function h(e){var t=e.components,a=(0,n.Z)(e,s);return(0,r.kt)("wrapper",(0,i.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"CTypes are standardised structures for credentials; the JSON scheme which describes the fields in a claim type. These fields are filled out by the claimer, indicating the information that needs to be attested. A CType (and subsequently when attested, the credential) may contain several \u201cattributes\u201d, for example, full name, date of birth, access level and id number.")),(0,r.kt)("h2",{id:"json-schema"},"Json-Schema"),(0,r.kt)("p",null,"KILT uses ",(0,r.kt)("a",{parentName:"p",href:"https://json-schema.org/"},"JSON-Schema")," (currently draft-07) to validate and annotate data in a strict format. This data format for ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/KILTprotocol/sdk-js/blob/develop/packages/core/src/ctype/CTypeSchema.ts"},"CType models")," forms a CType with definition characteristics. The following are all required properties of the schema, with no additional properties allowed:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Identifier: ",(0,r.kt)("inlineCode",{parentName:"li"},"$id")," in the format ",(0,r.kt)("inlineCode",{parentName:"li"},"kilt:ctype:0x{cTypeHash}")),(0,r.kt)("li",{parentName:"ul"},"KILT specific JSON-Schema: '",(0,r.kt)("a",{parentName:"li",href:"http://kilt-protocol.org/draft-01/ctype-input#"},"http://kilt-protocol.org/draft-01/ctype-input#"),"'"),(0,r.kt)("li",{parentName:"ul"},"Title: defines a user-friendly name for the CType that makes it easier for users to contextualise"),(0,r.kt)("li",{parentName:"ul"},"Properties: Each property is the attribute the claimer wishes to have attested by the attester.")),(0,r.kt)("h3",{id:"properties"},"Properties"),(0,r.kt)("p",null,"When making a claim for a CType, all the following properties are required:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"One of the following fields: ",(0,r.kt)("inlineCode",{parentName:"li"},"type")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"$ref")),(0,r.kt)("li",{parentName:"ul"},"A type of 'string', 'integer', 'number' and 'boolean' to define the attribute"),(0,r.kt)("li",{parentName:"ul"},"Nested JSON schemas can be referenced by a ",(0,r.kt)("inlineCode",{parentName:"li"},"uri")," using ",(0,r.kt)("inlineCode",{parentName:"li"},"$ref"),"(giving the advantage of being able to reference other CTypes)"),(0,r.kt)("li",{parentName:"ul"},"The format field is optionally:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Date format e.g. 2012-04-23T18:25:43.511Z"),(0,r.kt)("li",{parentName:"ul"},"Time format e.g. T18:25:43.511Z"),(0,r.kt)("li",{parentName:"ul"},"URI format e.g. ",(0,r.kt)("a",{parentName:"li",href:"https://www.example.com"},"https://www.example.com"))))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"{\n  $id: 'kilt:ctype0xda3861a45e0197f3ca145c2c209f9126e5053fas503e459af4255cf8011d51010',\n  $schema: 'http://kilt-protocol.org/draft-01/ctype#',\n  title: 'CtypeModel 2',\n  properties: {\n    name: { type: 'string' },\n    age: { $ref: `kilt:ctype:0x1`, },\n    },\n  type: 'object',\n}\n")),(0,r.kt)("h3",{id:"referencing"},"Referencing"),(0,r.kt)("p",null,"JSON-schema provide a referencing keyword ",(0,r.kt)("inlineCode",{parentName:"p"},"$ref")," that can be used as a pointer from other JSON schemas. This allows CTypes to either reference fields in other CTypes or nest entire CTypes within one another, providing flexibility for several different use cases."),(0,r.kt)("p",null,"This facility requires all JSON objects to build the schema and allows the reuse of previous schemas, reducing the need for copy-and-paste."),(0,r.kt)("p",null,"A claim from a nested CType requires the given CType, a list of comprised schemas, the claim content and the address of the owner."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"nested = {\n  $id: 'kilt:ctype:0xda3861a45e0197f3ca145c2c20f9f126e5053fas503e459af4255cf8011d51010',\n  $schema: 'http://kilt-protocol.org/draft-01/ctype#',\n  title: 'KYC and Passport',\n  type: 'object',\n  properties: {\n    fullName: {\n      $ref: `${passport.schema.$id}#/properties/fullName`,\n    },\n    passportIdentifer: {\n      $ref: `${passport.schema.$id}#/properties/passportIdentifer`,\n    },\n    streetAddress: {\n      $ref: `${passport.schema.$id}#/properties/streetAddress`,\n    },\n    city: {\n      $ref: `${passport.schema.$id}#/properties/city`,\n    },\n    state: {\n      $ref: `${passport.schema.$id}#/properties/state`,\n    },\n    ID: {\n      $ref: `${kyc.schema.$id}#/properties/ID`,\n    },\n    number: {\n      $ref: `${kyc.schema.$id}#/properties/number`,\n    },\n    name: {\n      $ref: `${kyc.schema.$id}#/properties/name`,\n    },\n  },\n}\n")),(0,r.kt)("h2",{id:"ctype-metadata"},"CType Metadata"),(0,r.kt)("p",null,"CType Metadata can be linked to a given CType to give context of its intended use-case: These include the:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Title"),(0,r.kt)("li",{parentName:"ul"},"Description"),(0,r.kt)("li",{parentName:"ul"},"Properties",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Title"),(0,r.kt)("li",{parentName:"ul"},"Description")))),(0,r.kt)("h2",{id:"hashing"},"Hashing"),(0,r.kt)("p",null,"The hash of the CType is used to identify and anchor it to the chain. This ",(0,r.kt)("inlineCode",{parentName:"p"},"hash")," is stored on-chain via the store method."),(0,r.kt)("h3",{id:"constructing-the-hash-for-the-id"},"Constructing the ",(0,r.kt)("inlineCode",{parentName:"h3"},"hash")," for the ",(0,r.kt)("inlineCode",{parentName:"h3"},"$id")),(0,r.kt)("p",null,"KILT uses the hashing algorithm blake2b as a hex string. The object is sorted by a canonicalization algorithm before hashing to ensure that semantically equivalent CTypes with different order of their properties would produce the same output hash."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"hash")," is made from the schema object from the following values:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$schema")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"properties"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$id")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$ref")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"type")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"title")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"type"),"\nExcluding"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$id"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"hashVal = {\n  $schema: schema.$schema,\n  properties: schema.properties,\n  title: schema.title,\n  type: schema.type,\n}\n")),(0,r.kt)("p",null,"The hash has a prefix of ",(0,r.kt)("inlineCode",{parentName:"p"},"kilt:ctype")," followed by the hex string. A typical ",(0,r.kt)("inlineCode",{parentName:"p"},"CTypeHash")," value would look like: ",(0,r.kt)("inlineCode",{parentName:"p"},"kilt:ctype:0xba15bf4960766b0a6ad7613aa3338edce95df6b22ed29dd72f6e72d740829b84")),(0,r.kt)("h2",{id:"storing-ctypes"},"Storing CTypes"),(0,r.kt)("p",null,"CTypes are not stored in a centralised storage database. When a credential is created, the schema ",(0,r.kt)("inlineCode",{parentName:"p"},"$id"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"cTypeHash")," is stored on-chain. The hash can then be verified and referenced at any time by making a call to the KILT blockchain to check if the corresponding CType matches the stored ",(0,r.kt)("inlineCode",{parentName:"p"},"$id"),"."),(0,r.kt)("p",null,"A Nested CType is a hierarchical composite schema that includes other simpler CTypes as substructures. The Nested CType needs to list all the included sub-CTypes. This allows verification of the owners of the included CTypes on-chain using the CType hash. For example, a company could use a Nested CType that includes the required credentials, qualifications, health and safety certs, etc of its current employees."),(0,r.kt)("h2",{id:"exchange-of-ctypes-with-different-actors"},"Exchange of CTypes with different actors"),(0,r.kt)("p",null,"There are three actors in the KILT workflow: Claimers (the holder of the credential), Attesters (who do the work and approve or reject the credential) and Verifiers (who require a credential from a Claimer)."),(0,r.kt)("p",null,"A Claimer can apply for a new credential by requesting a CType from the Attester. The Claimer then completes the CType and sends the information to be attested to the Attester. The Attester confirms the information and returns a credential."),(0,r.kt)("p",null,"A Verifier can request a credential from a Claimer that follows a given CType/schema. For example, a gaming company may request a specific credential to verify the gamer's ranking. Depending on how this credential was created initially, this can be done with the software development kit (SDK) messaging, or in other ways independent of the protocol (e.g., via email, QR code, etc.)"),(0,r.kt)("p",null,"Each actor in the system can verify the ownership and validity of the given CType at any time."))}h.isMDXComponent=!0}}]);